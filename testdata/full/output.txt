<html><head><meta charset="utf-8"></meta></head><body><page>
<h1>Interfaces and Generics</h1>

<p>Interfaces in Go provide a way to specify the behavior of an object; “If something can do this, then it can be used here”. In this lesson we will look at how to use interfaces to abstract behavior. Later in this lesson we will learn how Generics can be used to further refine interfaces. Concepts such as the <code>Empty Interface</code>, satisfying multiple interfaces, value vs. pointer receivers, and asserting for behavior will be covered in this lesson.</p>
</page><!--BREAK-->
<include src="concrete/concrete.md"><page>
<h1>Concrete Types Vs. Interfaces</h1>

<p>Interfaces allow us to specify behavior. They are about doing, not being. Interfaces also allow us to abstract code to make it more reusable, extensible, and more testable.</p>

<p>To illustrate this, let’s consider the concept of a performance venue. A performance venue should allow a variety of performers to perform at the venue.</p>

<p>An example of a this as a function might look like the following function.</p>

<pre><code class="language-go" language="go" src="concrete/src/concrete" sym="PerformAtVenue">func PerformAtVenue(m Musician) {
	m.Perform()
}</code></pre>

<p>The <code>PerformAtVenue</code> function takes a <code>Musician</code> as an argument and calls the <code>Perform</code> method on the musician. The <code>Musician</code> type is a concrete type.</p>

<pre><code class="language-go" language="go" src="concrete/src/concrete" sym="Musician">type Musician struct {
	Name string
}

func (m Musician) Perform()</code></pre>

<p>When we pass a <code>Musician</code> to the <code>PerformAtVenue</code> function, our code compiles and we get the expected output.</p>

<div><div><p><pre><code class="language-go#example" code="main.go#example" exec="go run ." language="go#example" src="concrete/src/concrete/main.go#example">func main() {
	m := Musician{Name: &#34;Kurt&#34;}
	PerformAtVenue(m)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="concrete/src/concrete/main.go#example" target="_blank">concrete/src/concrete/main.go</a>
    </p>
</figcaption></div><cmd code="main.go#example" exec="go run ." src="concrete/src/concrete"><pre class="code-block"><code class="language-text" language="text">$ go run .

Kurt is singing
--------------------------------------------------------------------------------
duration: 155.843835ms
go:       go1.18</code></pre></cmd></div>

<p>Because the <code>PerformAtVenue</code> function takes a <code>Musician</code> as an argument, which is a concrete type, we are restricted as to who can perform at the venue. For example, if we were to try to pass a <code>Poet</code> to the <code>PerformAtVenue</code> function, we would get a compilation error.</p>

<pre><code class="language-go" language="go" src="concrete/src/broken" sym="Poet">type Poet struct {
	Name string
}

func (p Poet) Perform()</code></pre>

<div><div><p><pre><code class="language-go#example" code="main.go#example" exec="go run ." exit="2" language="go#example" src="concrete/src/broken/main.go#example">func main() {
	m := Musician{Name: &#34;Kurt&#34;}
	PerformAtVenue(m)

	p := Poet{Name: &#34;Janis&#34;}
	PerformAtVenue(p)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="concrete/src/broken/main.go#example" target="_blank">concrete/src/broken/main.go</a>
    </p>
</figcaption></div><cmd code="main.go#example" exec="go run ." exit="2" src="concrete/src/broken"><pre class="code-block"><code class="language-text" language="text">$ go run .

--------------------------------------------------------------------------------
STDERR:

# demo
./main.go:34:17: cannot use p (variable of type Poet) as type Musician in argument to PerformAtVenue
--------------------------------------------------------------------------------
duration: 88.373667ms
go:       go1.18</code></pre></cmd></div>

<p>Interfaces allow us to solve this problem by specifying a common set of methods that are required by the <code>PerformAtVenue</code> function.</p>

<p>In this example, we can introduce a <code>Performer</code> interface. This interface specifies that a <code>Perform</code> method is required to implement the <code>Performer</code> interface.</p>

<pre><code class="language-go" language="go" src="concrete/src/fixed" sym="Performer">type Performer interface {
	Perform()
}</code></pre>

<p>Both the <code>Musician</code> and <code>Poet</code> types have the <code>Perform</code> method. Therefore, we can implement the <code>Performer</code> interface on both of these types. By updating the <code>PerformAtVenue</code> function to take a <code>Performer</code> as an argument, we are now able to pass a <code>Musician</code> or a <code>Poet</code> to the <code>PerformAtVenue</code> function.</p>

<p><pre><code class="language-go" language="go" src="concrete/src/fixed" sym="PerformAtVenue">func PerformAtVenue(p Performer) {
	p.Perform()
}</code></pre>
<cmd exec="go run ." src="concrete/src/fixed"><pre class="code-block"><code class="language-text" language="text">$ go run .

Kurt is singing
Janis is reading poetry
--------------------------------------------------------------------------------
duration: 152.911927ms
go:       go1.18</code></pre></cmd></p>

<p>By using an interface, instead of a concrete type, we are able to abstract the code and make it more flexible and expandable.</p>
</page><!--BREAK-->
</include>
<include src="explicit.md"><page>
<h1>Explicit Interface Implementation</h1>

<p>In a lot of object oriented languages, such as C# and Java, you have to <em>explicitly</em> declare that your type is implementing a very specific interface.</p>

<p>In C#, for example, you declare that you are using the <code>Performer</code> interface by using the <code>:</code> operator after the class name and listing the interfaces you want to use.</p>

<pre class="code-block"><code class="language-c#" language="c#">// C#
interface Performer {
	void Perform();
}

// explicitly implements Performer
class Musician : Performer {
	public void Perform() {}
}
</code></pre>

<p>In Java you use the <code>implements</code> keyword after the class name to tell the compiler that your type wants to implement the <code>Performer</code> interface.</p>

<pre class="code-block"><code class="language-java" language="java">// Java
interface Performer {
	void Perform();
}

// explicitly implements Performer
class Musician implements Performer {
	void Perform() {}
}
</code></pre>
</page><!--BREAK-->
</include>
<include src="implicit/implicit.md"><page>
<h1>Implicit Interface Implementation</h1>

<p>In Go interfaces are implemented <em>implicitly</em>. This means we don’t have indicate to Go that we are implementing an interface. Given a <code>Performer</code> interface, a type would need to implement the <code>Perform</code> method to be considered a performer.</p>

<pre><code class="language-go" language="go" src="implicit/src/implicit" sym="Performer">type Performer interface {
	Perform()
}</code></pre>

<p>By adding a <code>Perform</code> method, that matches the signature of the <code>Performer</code> interface, the <code>Musician</code> type is now implicitly implementing the <code>Performer</code> interface.</p>

<pre><code class="language-go" language="go" src="implicit/src/implicit" sym="-all Musician">type Musician struct {
	Name string
}

// Perform implicitly implements the Performer interface
func (m Musician) Perform() {
	fmt.Println(m.Name, &#34;is singing&#34;)
}</code></pre>

<p>Provided a type implements all behaviors specified in the interface, it can be said to implement that interface. The compiler will check to make sure a type is acceptable and will report an error if it does not. Sometimes this is called <strong>Duck Typing</strong>, but since it happens at compile-time in Go, it is called <strong>Structural typing</strong>.</p>

<div><div><p><pre><code class="language-go#example" code="main.go#example" exec="go run ." language="go#example" src="implicit/src/implicit/main.go#example">func PerformAtVenue(p Performer) {
	p.Perform()
}

func main() {
	m := Musician{Name: &#34;Kurt&#34;}
	PerformAtVenue(m)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="implicit/src/implicit/main.go#example" target="_blank">implicit/src/implicit/main.go</a>
    </p>
</figcaption></div><cmd code="main.go#example" exec="go run ." src="implicit/src/implicit"><pre class="code-block"><code class="language-text" language="text">$ go run .

Kurt is singing
--------------------------------------------------------------------------------
duration: 159.282059ms
go:       go1.18</code></pre></cmd></div>

<p>Structural typing has a handle of useful side-effects.</p>

<ul>
<li>The concrete type does not need to know about your interface</li>
<li>You are able to write interfaces for concrete types that already exist</li>
<li>You can write interfaces for other people’s types, or types that appear in other packages</li>
</ul>

<blockquote>
<p>Suggested Reading: <a href="https://en.wikipedia.org/wiki/Duck_typing">Duck typing</a></p>

<p>Suggested Reading: <a href="https://en.wikipedia.org/wiki/Structural_type_system">Structural typing</a></p>
</blockquote>
</page><!--BREAK-->
</include>
<include src="before/before.md"><page>
<h1>Before Interfaces</h1>

<p>Consider the following function definition. This function takes a pointer to <a href="https://golang.org/pkg/os/#File"><code>os.File</code></a>, along with a slice of bytes. The function then calls the <a href="https://golang.org/pkg/os/#File.Write"><code>os.File.Write</code></a> function with the data passed in.</p>

<pre><code class="language-go" language="go" src="before/src/writer-before" sym="WriteData">func WriteData(w *os.File, data []byte) {
	w.Write(data)
}</code></pre>

<p>In order to call this function we must have an <code>*os.File</code>, which is a concrete type in the system. In order to call this function we either need to retrieve, or create, a file on the filesystem, or we can use <a href="https://golang.org/pkg/os/#pkg-variables"><code>os.Stdout</code></a> which is an <code>*os.File</code>.</p>

<pre><code class="language-go" language="go" src="before/src/writer-before" sym="main">func main() {
	WriteData(os.Stdout, []byte(&#34;Hello, World!&#34;))
}</code></pre>

<p>Testing this function involves significant setup. We need to create a new file, call the <code>WriteData</code> function, close the file, re-open the file, read the file, and then compare the contents. We need to do all of this work in order to be able to call one function, <code>Write</code>, on <code>*os.File</code>.</p>

<div><div><p><pre><code class="language-go#test" code="main_test.go#test" exec="go test -v" hide-duration="true" language="go#test" src="before/src/writer-before/main_test.go#test">func Test_WriteData(t *testing.T) {
	t.Parallel()

	dir, err := ioutil.TempDir(&#34;&#34;, &#34;example&#34;)
	if err != nil {
		t.Fatal(err)
	}

	fn := filepath.Join(dir, &#34;hello.txt&#34;)

	f, err := os.Create(fn)

	if err != nil {
		t.Fatal(err)
	}

	data := []byte(&#34;Hello, World!&#34;)
	WriteData(f, data)

	f.Close()

	f, err = os.Open(fn)
	if err != nil {
		t.Fatal(err)
	}

	b, err := ioutil.ReadAll(f)
	if err != nil {
		t.Fatal(err)
	}

	act := string(b)
	exp := string(data)
	if act != exp {
		t.Fatalf(&#34;expected %q, got %q&#34;, exp, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="before/src/writer-before/main_test.go#test" target="_blank">before/src/writer-before/main_test.go</a>
    </p>
</figcaption></div><cmd code="main_test.go#test" exec="go test -v" hide-duration="true" src="before/src/writer-before"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_WriteData
=== PAUSE Test_WriteData
=== CONT  Test_WriteData
--- PASS: Test_WriteData (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>The <code>WriteData</code> function is a prime candidate to be refactored using interfaces.</p>
</page><!--BREAK-->
</include>
<include src="after/after.md"><page>
<h1>Using Interfaces</h1>

<p>One of the most well known interfaces in Go is the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interface. The <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interface requires the implementation of a <code>Write</code> method that matches the signature of <code>Write(p []byte) (n int, err error)</code>.</p>

<cmd exec="go doc io.Writer" hide-duration="true"><pre class="code-block"><code class="language-text" language="text">$ go doc io.Writer

package io // import &#34;io&#34;

type Writer interface {
	Write(p []byte) (n int, err error)
}
    Writer is the interface that wraps the basic Write method.

    Write writes len(p) bytes from p to the underlying data stream. It returns
    the number of bytes written from p (0 &lt;= n &lt;= len(p)) and any error
    encountered that caused the write to stop early. Write must return a non-nil
    error if it returns n &lt; len(p). Write must not modify the slice data, even
    temporarily.

    Implementations must not retain p.

var Discard Writer = discard{}
func MultiWriter(writers ...Writer) Writer
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>Implementations of the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interface can be found all of over the standard library, as well as third party packages. A few of the most common implementations of the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interface are: <godoc#a for="os#File"><a href="https://pkg.go.dev/os#File" target="_blank"><code>os.File</code></a></godoc#a>, <godoc#a for="bytes#Buffer"><a href="https://pkg.go.dev/bytes#Buffer" target="_blank"><code>bytes.Buffer</code></a></godoc#a>, and <godoc#a for="strings#Builder"><a href="https://pkg.go.dev/strings#Builder" target="_blank"><code>strings.Builder</code></a></godoc#a>.</p>

<p>Knowing that the only portion of <godoc#a for="os#File"><a href="https://pkg.go.dev/os#File" target="_blank"><code>os.File</code></a></godoc#a> we are using matches the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interface we can modify the <code>WriteData</code> to use the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a>, and improve the compatibility and testability of the method.</p>

<pre><code class="language-go" language="go" src="after/src/writer-after" sym="WriteData">func WriteData(w io.Writer, data []byte) {
	w.Write(data)
}</code></pre>

<p>The usage of the <code>WriteData</code> function does not change.</p>

<pre><code class="language-go" language="go" src="after/src/writer-after" sym="main">func main() {
	WriteData(os.Stdout, []byte(&#34;Hello, World!&#34;))
}</code></pre>

<p>Testing the <code>WriteData</code> function also becomes easier now that we can substitute the implementation with an easier to test implementation.</p>

<div><div><p><pre><code class="language-go#test" code="main_test.go#test" exec="go test -v" hide-duration="true" language="go#test" src="after/src/writer-after/main_test.go#test">func Test_WriteData(t *testing.T) {
	t.Parallel()

	// create a buffer to write to
	bb := &amp;bytes.Buffer{}

	data := []byte(&#34;Hello, World!&#34;)

	// write the data to the buffer
	WriteData(bb, data)

	// capture the data written to the buffer
	// to the act variable
	act := bb.String()

	exp := string(data)

	// compare the expected and actual values
	if act != exp {
		t.Fatalf(&#34;expected %q, got %q&#34;, exp, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="after/src/writer-after/main_test.go#test" target="_blank">after/src/writer-after/main_test.go</a>
    </p>
</figcaption></div><cmd code="main_test.go#test" exec="go test -v" hide-duration="true" src="after/src/writer-after"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_WriteData
=== PAUSE Test_WriteData
=== CONT  Test_WriteData
--- PASS: Test_WriteData (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>
</page><!--BREAK-->
</include>
<include src="implementing/implementing.md"><page>
<h1>Implementing io.Writer</h1>

<p>Now that <code>WriteData</code> uses the <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> we can, not only use implementations from the standard library like <godoc#a for="os#File"><a href="https://pkg.go.dev/os#File" target="_blank"><code>os.File</code></a></godoc#a> and <godoc#a for="bytes#Buffer"><a href="https://pkg.go.dev/bytes#Buffer" target="_blank"><code>bytes.Buffer</code></a></godoc#a>, we can create our own implementation of <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a>.</p>

<pre><code class="language-go" language="go" src="implementing/src/func-custom" sym="-all Scribe">type Scribe struct {
	data []byte
}

func (s Scribe) String() string {
	return string(s.data)
}

func (s *Scribe) Write(p []byte) (int, error) {
	s.data = p
	return len(p), nil
}</code></pre>

<p>By implementing the <code>Write</code> function, with the proper signature, we don’t have to implicitly declare our type as an <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a>. The compiler is able to determine whether or not the type being passed in implements the interface being requested.</p>

<div><div><p><pre><code class="language-go#bad" code="main.go#bad" exec="go run ." exit="2" language="go#bad" src="implementing/src/func-custom-bad/main.go#bad">func main() {
	WriteData(42, []byte(&#34;Hello, World!&#34;))
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="implementing/src/func-custom-bad/main.go#bad" target="_blank">implementing/src/func-custom-bad/main.go</a>
    </p>
</figcaption></div><cmd code="main.go#bad" exec="go run ." exit="2" src="implementing/src/func-custom-bad"><pre class="code-block"><code class="language-text" language="text">$ go run .

--------------------------------------------------------------------------------
STDERR:

# demo
./main.go:16:12: cannot use 42 (constant of type int) as type io.Writer in argument to WriteData:
	int does not implement io.Writer (missing Write method)
--------------------------------------------------------------------------------
duration: 73.166057ms
go:       go1.18</code></pre></cmd></div>

<p>The <code>*Scribe</code> type can also be used to test <code>WriteData</code> like we did with <godoc#a for="bytes#Buffer"><a href="https://pkg.go.dev/bytes#Buffer" target="_blank"><code>bytes.Buffer</code></a></godoc#a>.</p>

<div><div><p><pre><code class="language-go#test" code="main_test.go#test" exec="go test -v" hide-duration="true" language="go#test" src="implementing/src/func-custom/main_test.go#test">func Test_WriteData(t *testing.T) {
	t.Parallel()

	scribe := &amp;Scribe{}
	data := []byte(&#34;Hello, World!&#34;)
	WriteData(scribe, data)

	act := scribe.String()
	exp := string(data)
	if act != exp {
		t.Fatalf(&#34;expected %q, got %q&#34;, exp, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="implementing/src/func-custom/main_test.go#test" target="_blank">implementing/src/func-custom/main_test.go</a>
    </p>
</figcaption></div><cmd code="main_test.go#test" exec="go test -v" hide-duration="true" src="implementing/src/func-custom"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_WriteData
=== PAUSE Test_WriteData
=== CONT  Test_WriteData
--- PASS: Test_WriteData (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>
</page><!--BREAK-->
</include>
<include src="multiple/multiple.md"><page>
<h1>Multiple Interfaces</h1>

<p>Because interfaces are implemented implicitly it means that types can implement many interfaces at once, without explicit declaration. In addition to implementing <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> the <code>Scribe</code> type also implements the <godoc#a for="fmt#Stringer"><a href="https://pkg.go.dev/fmt#Stringer" target="_blank"><code>fmt.Stringer</code></a></godoc#a> interface.</p>

<cmd exec="go doc fmt.Stringer" hide-duration="true"><pre class="code-block"><code class="language-text" language="text">$ go doc fmt.Stringer

package fmt // import &#34;fmt&#34;

type Stringer interface {
	String() string
}
    Stringer is implemented by any value that has a String method, which defines
    the “native” format for that value. The String method is used to print
    values ****ed as an operand to any format that accepts a string or to an
    unformatted printer such as Print.
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>The <godoc#a for="fmt#Stringer"><a href="https://pkg.go.dev/fmt#Stringer" target="_blank"><code>fmt.Stringer</code></a></godoc#a> interface is used to convert a value to a string. By implementing a <code>String() string</code> method on the <code>Scribe</code> type, the <code>Scribe</code> now implements both the <godoc#a for="fmt#Stringer"><a href="https://pkg.go.dev/fmt#Stringer" target="_blank"><code>fmt.Stringer</code></a></godoc#a> and <godoc#a for="io#Writer"><a href="https://pkg.go.dev/io#Writer" target="_blank"><code>io.Writer</code></a></godoc#a> interfaces.</p>

<pre><code class="language-go" language="go" src="multiple/src/stringer" sym="Scribe.String">func (s Scribe) String() string {
	return string(s.data)
}</code></pre>
</page><!--BREAK-->
</include>
<include src="asserting_impl.md"><page>
<h1>Asserting Interface Implementation</h1>

<p>Often, especially while implementing an interface, it can be useful to assert your type conforms to all of the interfaces you are trying to implement. One way to do this is to declare a new variable, whose type is the interface you are implementing, and try to assign your type to it. Using the <code>_</code> character tells the compiler to do the assignment to the variable and then throw away the result. These assertions are usually done at the package level.</p>

<pre class="code-block"><code class="language-go" language="go">package main

var _ io.Writer = &amp;Scribe{}
var _ fmt.Stringer = Scribe{}
</code></pre>

<p>The compiler will keep failing until the <code>Scribe</code> type implements both the <code>io.Writer</code> and <code>fmt.Stringer</code> interfaces.</p>
</page><!--BREAK-->
</include>
<include src="empty.md"><page>
<h1>The Empty Interface</h1>

<p>All the interfaces we’ve seen so far have declared one or more methods. In Go there is no <strong>minimum</strong> method count for an interface. That means it is possible to have, what is called, an empty interface. If you declare an interface with zero methods, then every type in the system will be considered to have implemented it.</p>

<p>In Go we use the empty interface to represent “anything”.</p>

<pre class="code-block"><code class="language-go" language="go">// generic empty interface:
interface{} // aliased to &#34;any&#34;

// a named empty interface:
type foo interface{}
</code></pre>

<p>An <code>int</code>, for example, has no methods and because of that an <code>int</code> will match an interface with no methods.</p>

<h2>The “any” Keyword</h2>

<p>In <code>Go1.18</code>, <a href="https://go.dev/doc/tutorial/generics">generics</a> were added to the language. As part of this a new keyword, <code>any</code>, was added to the language. This keyword is an alias for <code>interface{}</code>.</p>

<p>Using <code>any</code> over <code>interface{}</code> is a good idea because it is more explicit and it is easier to read.</p>

<pre class="code-block"><code class="language-go" language="go">// Go 1.x:
func foo(x interface{}) {
    // ...
}

// Go 1.18:
func foo(x any) {
    // ...
}
</code></pre>

<p>If using <code>Go1.18</code>, or greater, then you can use the <code>any</code> keyword instead of <code>interface{}</code>. Using <code>any</code> instead of <code>interface{}</code> is considered to be idiomatic.</p>

<h2>The Problem With Empty Interfaces</h2>

<blockquote>
<p>interface{} says nothing. – Rob Pike</p>
</blockquote>

<p>It is considered bad practice in Go to overuse the empty interface. You should always try to accept either a concrete type or a non-empty interface.</p>

<p>While there are valid reasons to use an empty interface, the downsides should be considered first:</p>

<ul>
<li>No type information</li>
<li>Runtime panics are <em>very</em> possible</li>
<li>Difficult code (to test, understand, document, etc…)</li>
</ul>

<h2>Using an Empty Interface</h2>

<p>Consider we are writing a data store, similar to a database. We might have an <code>Insert</code> method that takes id and the value we want to store. This <code>Insert</code> method should be able to our data models. These models might represent users, widgets, orders, etc.</p>

<p>We can use the empty interface to accept all of our models and insert them into the data store.</p>

<div><p><pre><code class="language-go" language="go" snippet="func" src="src/store/start/store.go">func (s *Store) Insert(id int, m any) error {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/start/store.go" target="_blank">src/store/start/store.go</a>
    </p>
</figcaption></div>

<p>Unfortunately, this means that in addition to our data models anybody may pass any type to our data store. This is, clearly, not our desire. We could try an set up an elaborate set of <code>if/else</code> or <code>switch</code> statements, but, this becomes untenable and unmanageable over time. Interfaces allow us to filter out unwanted types and only allow through types that we want.</p>
</page><!--BREAK-->
</include>
<include src="defining.md"><page>
<h1>Defining Interfaces</h1>

<p>You can create a new interface in the Go type system by using the <code>type</code> keyword, giving the new type a name, and then basing that new type on the <code>interface</code> type.</p>

<pre class="code-block"><code class="language-go" language="go">type MyInterface interface {}
</code></pre>

<p>Interfaces define behavior, therefore they are only a collection of methods. Interfaces can have zero, one, or many methods.</p>

<blockquote>
<p>The larger the interface, the weaker the abstraction. – Rob Pike</p>
</blockquote>

<p>It is considered to be non-idiomatic to have large interfaces. Keep the number of methods per interface as small as possible. Small interfaces allow for easier interface implementations, especially when testing. Small interfaces also help us keep our functions and methods small in scope making them more maintainable and testable.</p>

<pre class="code-block"><code class="language-go" language="go">type MyInterface interface {
	Method1()
	Method2() error
	Method3() (string, error)
}
</code></pre>

<p>It is important to note that interfaces are a collection of methods, not fields. In Go only structs have fields, however, any type in the system can have methods. This is why interfaces are limited to methods only.</p>

<pre class="code-block"><code class="language-go" language="go">// valid
type Writer interface {
	Write(p []byte) (int, error)
}

// invalid
type Emailer interface {
	Email string
}
</code></pre>

<h2>Defining a Model Interface</h2>

<p>Consider, again, the <code>Insert</code> method for our data store. The method takes two arguments. The first argument is the ID of the model to be stored. The second argument, should be one of our data models, however, because we are using an empty interface, any type from <code>int</code> to <code>nil</code> may be passed in.</p>

<div><p><pre><code class="language-go" language="go" snippet="func" src="src/store/start/store.go">func (s *Store) Insert(id int, m any) error {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/start/store.go" target="_blank">src/store/start/store.go</a>
    </p>
</figcaption></div>

<div><div><p><pre><code class="language-go#example" code="store_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="src/store/start/store_test.go#example">func Test_Store_Insert(t *testing.T) {
	t.Parallel()

	// create a store
	s := &amp;Store{
		data: Data{},
	}

	exp := 1

	// insert a non-valid type
	err := s.Insert(exp, func() {})
	if err != nil {
		t.Fatal(err)
	}

	// retreive the type
	act, err := s.Find(exp)
	if err != nil {
		t.Fatal(err)
	}

	// assert the returned value is a func()
	_, ok := act.(func())
	if !ok {
		t.Fatalf(&#34;unexpected type %T&#34;, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/start/store_test.go#example" target="_blank">src/store/start/store_test.go</a>
    </p>
</figcaption></div><cmd code="store_test.go#example" exec="go test -v" hide-duration="true" src="src/store/start"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Store_Insert
=== PAUSE Test_Store_Insert
=== CONT  Test_Store_Insert
--- PASS: Test_Store_Insert (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>To prevent types, such as a function definition, that aren’t an expected data model, we can define an interface to solve this problem. Since the <code>Insert</code> function needs an ID for insertion, we can use that as the basis for an interface.</p>

<pre><code class="language-go" language="go" src="src/store/model" sym="Model">type Model interface {
	ID() int
}</code></pre>

<p>To implement the <code>Model</code> interface a type must have a <code>ID() int</code> method. We can cleanup the <code>Insert</code> method’s definition by accepting a single argument, the <code>Model</code> interface.</p>

<div><p><pre><code class="language-go" language="go" snippet="func" src="src/store/model/store.go">func (s *Store) Insert(m Model) error {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/model/store.go" target="_blank">src/store/model/store.go</a>
    </p>
</figcaption></div>

<p>Now, the compiler and/or runtime will reject any type that, such as <code>string</code>, <code>[]byte</code>, and <code>func()</code>, that doesn’t have a <code>ID() int</code> method.</p>

<div><div><p><pre><code class="language-go#example" code="store_test.go#example" exec="go test -v" exit="2" hide-duration="true" language="go#example" src="src/store/model/store_test.go#example">func Test_Store_Insert(t *testing.T) {
	t.Parallel()

	// create a store
	s := &amp;Store{}

	exp := 1

	// insert a non-valid type
	err := s.Insert(func() {})
	if err != nil {
		t.Fatal(err)
	}

	// retreive the type
	act, err := s.Find(exp)
	if err != nil {
		t.Fatal(err)
	}

	// assert the returned value is a func()
	_, ok := act.(func())
	if !ok {
		t.Fatalf(&#34;unexpected type %T&#34;, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/model/store_test.go#example" target="_blank">src/store/model/store_test.go</a>
    </p>
</figcaption></div><cmd code="store_test.go#example" exec="go test -v" exit="2" hide-duration="true" src="src/store/model"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./store_test.go:15:18: cannot use func() {} (value of type func()) as type Model in argument to s.Insert:
	func() does not implement Model (missing ID method)
./store_test.go:27:11: impossible type assertion: act.(func())
	func() does not implement Model (missing ID method)
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<h2>Implementing the Interface</h2>

<p>Finally, let’s create a new type, <code>User</code>, that implements the <code>Model</code> interface.</p>

<pre><code class="language-go" language="go" src="src/store/user" sym="User">type User struct {
	UID int
}

func (u User) ID() int</code></pre>

<p>When we update the tests to use the <code>User</code> type, our tests now pass.</p>

<div><div><p><pre><code class="language-go#example" code="store_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="src/store/user/store_test.go#example">func Test_Store_Insert(t *testing.T) {
	t.Parallel()

	// create a store
	s := &amp;Store{
		data: Data{},
	}

	// create a user
	exp := User{UID: 1}

	// insert the user
	err := s.Insert(exp)
	if err != nil {
		t.Fatal(err)
	}

	// retreive the user
	act, err := s.Find(exp.UID)
	if err != nil {
		t.Fatal(err)
	}

	// assert the returned value is a user
	actu, ok := act.(User)
	if !ok {
		t.Fatalf(&#34;unexpected type %T&#34;, act)
	}

	// assert the returned user is the same as the inserted user
	if exp.UID != actu.UID {
		t.Fatalf(&#34;expected %v, got %v&#34;, exp, actu)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/user/store_test.go#example" target="_blank">src/store/user/store_test.go</a>
    </p>
</figcaption></div><cmd code="store_test.go#example" exec="go test -v" hide-duration="true" src="src/store/user"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Store_Insert
=== PAUSE Test_Store_Insert
=== CONT  Test_Store_Insert
--- PASS: Test_Store_Insert (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>
</page><!--BREAK-->
</include>
<include src="combining.md"><page>
<h1>Complex Interfaces</h1>

<h2>Embedding Interfaces</h2>

<p>Interfaces in Go can embed one or more interfaces within itself. This can be used to great effect to combine behaviors into more complex behaviors. The <a href="https://pkg.go.dev/io"><code>io</code></a> package defines many interfaces, including interfaces that are composed of other interfaces, such as <a href="https://pkg.go.dev/io#ReadWriter"><code>io.ReadWriter</code></a> and <a href="https://pkg.go.dev/io#ReadWriteCloser"><code>io.ReadWriteCloser</code></a>.</p>

<cmd exec="go doc io.ReadWriteCloser" hide-duration="true"><pre class="code-block"><code class="language-text" language="text">$ go doc io.ReadWriteCloser

package io // import &#34;io&#34;

type ReadWriteCloser interface {
	Reader
	Writer
	Closer
}
    ReadWriteCloser is the interface that groups the basic Read, Write and Close
    methods.
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>The alternative to embedding other interfaces would to re-declare those same methods in the combined interface.</p>

<pre class="code-block"><code class="language-go" language="go">package io

// ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.
type ReadWriteCloser interface {
  Read(p []byte) (n int, err error)
  Write(p []byte) (n int, err error)
  Close() error
}
</code></pre>

<p>This is, however, the wrong thing to do. If the intention, as is with <code>io.ReadWriter</code>, is implement the <code>io.Reader</code> interface, and the <code>io.Reader</code> interface changes, then it would no longer implement the correct interface. Embedding the desired interfaces allows us to keep our interfaces cleaner and more resilient.</p>

<h2>Defining an Validatable Interface</h2>

<p>Since the act of inserting a model is different than the act of updating a model, we can define an interface to ensure that only types that are <strong>both</strong> a <code>Model</code> and have a <code>Validate() error</code> method can be inserted.</p>

<pre><code class="language-go" language="go" src="src/store/validatable" sym="Validatable">type Validatable interface {
	Model
	Validate() error
}</code></pre>

<p>The <code>Validatable</code> interface embeds the <code>Model</code> interface and introduces a new method, <code>Validate() error</code>, that must be implemented in addition to the method requirements of the <code>Model</code> interface. The <code>Validate() error</code> method allows the data model to validate itself before insertion.</p>

<div><p><pre><code class="language-go" language="go" snippet="func" src="src/store/validatable/store.go">func (s *Store) Insert(m Validatable) error {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/validatable/store.go" target="_blank">src/store/validatable/store.go</a>
    </p>
</figcaption></div>

<pre><code class="language-go" language="go" src="src/store/validatable" sym="User.Validate">func (u User) Validate() error {
	return nil
}</code></pre>
</page><!--BREAK-->
</include>
<include src="assertion.md"><page>
<h1>Type Assertion</h1>

<p>With a concrete type, like an <code>int</code> or a <code>struct</code>, the Go compiler and/or runtime knows exactly what the capabilities of that type are. Interfaces, however, can be backed by any type that matches that interface. This means it is possible that the concrete type backing a particular interface provides additional functionality beyond the scope of the interface.</p>

<p>Go allows us to test an interface to see if its concrete implementation is of a certain type. In Go, this is called type assertion.</p>

<p>In this example we are asserting that variable <code>i</code>, of type <code>interface{}</code> (empty interface), also implements the <a href="https://pkg.go.dev/io#Writer"><code>io.Writer</code></a> interface. The result of this assertion is assigned to the variable <code>w</code>. The variable <code>w</code> is of type <code>io.Writer</code> and can be used as such.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/bad/assert.go">func WriteNow(i any) {
	w := i.(io.Writer)
	now := time.Now()
	w.Write([]byte(now.String()))
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/bad/assert.go" target="_blank">src/assertion/bad/assert.go</a>
    </p>
</figcaption></div>

<div><p><pre><code class="language-go" language="go" snippet="good-assert" src="src/assertion/bad/assert.go">bb := &amp;bytes.Buffer{}
WriteNow(bb)</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/bad/assert.go" target="_blank">src/assertion/bad/assert.go</a>
    </p>
</figcaption></div>

<p>What happens, however, when someone passes a type, such as an <code>int</code> or <code>nil</code>, that does <strong>not</strong> implement <code>io.Writer</code>?</p>

<div><p><pre><code class="language-go" language="go" snippet="bad-assert" src="src/assertion/bad/assert.go">WriteNow(42)</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/bad/assert.go" target="_blank">src/assertion/bad/assert.go</a>
    </p>
</figcaption></div>

<p>The result of a bad assertion is a <code>panic</code>.</p>

<cmd exec="go run ." exit="1" src="src/assertion/bad"><pre class="code-block"><code class="language-text" language="text">$ go run .

--------------------------------------------------------------------------------
STDERR:

panic: interface conversion: int is not io.Writer: missing method Write

goroutine 1 [running]:
main.WriteNow({0x106a240?, 0x108bf48})
	./assert.go:11 +0x30
main.main()
	./assert.go:25 +0x47
exit status 2
--------------------------------------------------------------------------------
duration: 168.640675ms
go:       go1.18</code></pre></cmd>

<p>These panics can, and will, crash your applications and need to be protected against.</p>

<h2>Asserting Assertion</h2>

<p>To prevent a runtime <code>panic</code> when a type assertion fails, we can capture a second argument during the assertion. This second variable is of type <code>bool</code> and will be <code>true</code> if the type assertion succeeded and false if it does not.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/good/assert.go">func WriteNow(i any) error {
	w, ok := i.(io.Writer)
	if !ok {
		return fmt.Errorf(&#34;expected io.Writer, got %T&#34;, i)
	}

	now := time.Now()
	w.Write([]byte(now.String()))

	return nil
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/good/assert.go" target="_blank">src/assertion/good/assert.go</a>
    </p>
</figcaption></div>

<p>You should <strong>ALWAYS</strong> check this boolean to prevent panics and to help keep your applications from crashing.</p>

<h2>Asserting Concrete Types</h2>

<p>In addition to asserting that one interface implements another interface, we can use type assertion to get the concrete type underneath.</p>

<p>In this example we trying to assert that variable <code>w</code>, of type <code>io.Writer</code>, to the type <a href="https://pkg.go.dev/bytes#Buffer"><code>*bytes.Buffer</code></a>. If the assertion is successful, <code>ok == true</code>, then variable <code>bb</code> will be of type <code>*bytes.Buffer</code> and we can now access any publicly exported fields and methods on <code>*bytes.Buffer</code>.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/concrete/assert.go">func WriteNow(w io.Writer) error {
	now := time.Now()

	if bb, ok := w.(*bytes.Buffer); ok {
		bb.WriteString(now.String())
		return nil
	}

	w.Write([]byte(now.String()))

	return nil
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/concrete/assert.go" target="_blank">src/assertion/concrete/assert.go</a>
    </p>
</figcaption></div>
</page><!--BREAK-->
<page>
<h1>Assertions Through Switch</h1>

<p>When we want to assert an interface for a variety of different types, we can use the <code>switch</code> statement in lieu of a lot of <code>if</code> statements. Using <code>switch</code> statements when doing type assertions also prevents the type assertion panics we saw earlier with individual type assertions.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/switch-basic/assert.go">func WriteNow(i any) error {

	now := time.Now().String()

	switch i.(type) {
	case *bytes.Buffer:
		fmt.Println(&#34;type was a *bytes.Buffer&#34;, now)
	case io.StringWriter:
		fmt.Println(&#34;type was a io.StringWriter&#34;, now)
	case io.Writer:
		fmt.Println(&#34;type was a io.Writer&#34;, now)
	}

	return fmt.Errorf(&#34;can not write to %T&#34;, i)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/switch-basic/assert.go" target="_blank">src/assertion/switch-basic/assert.go</a>
    </p>
</figcaption></div>

<h2>Capturing Switch Type</h2>

<p>While just switching on a type can be useful it is often much more useful to capture the result of the type assertion to a variable.</p>

<p>In the following example the result of the type assertion in the switch is assigned to the variable <code>t := i.(type)</code>.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/switch-good/assert.go">func WriteNow(i any) error {

	now := time.Now().String()

	switch t := i.(type) {
	case *bytes.Buffer:
		t.WriteString(now)
	case io.StringWriter:
		t.WriteString(now)
	case io.Writer:
		t.Write([]byte(now))
	}

	return fmt.Errorf(&#34;can not write to %T&#34;, i)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/switch-good/assert.go" target="_blank">src/assertion/switch-good/assert.go</a>
    </p>
</figcaption></div>

<p>In the case of <code>i</code> being of type <code>*bytes.Buffer</code> then the variable <code>t</code> will also be of type <code>*bytes.Buffer</code> and all publicly exported fields and methods of <code>*bytes.Buffer</code> can now be used.</p>

<h2>Beware of Case Order</h2>

<p>The <code>case</code> clauses in a <code>switch</code> statement are checked in the order that they are listed. A poorly organized <code>switch</code> statement can lead to incorrect matches.</p>

<p>In the following example since both <code>*bytes.Buffer</code> and <code>io.WriteStringer</code> implement <code>io.Writer</code>. The first <code>case</code> clause matches against <code>io.Writer</code> which will match both of those types and prevent the correct clause from being run.</p>

<div><p><pre><code class="language-go" language="go" snippet="def" src="src/assertion/switch-bad/assert.go">func WriteNow(i any) error {

	now := time.Now().String()

	switch t := i.(type) {
	case io.Writer:
		t.Write([]byte(now))
	case *bytes.Buffer:
		t.WriteString(now)
	case io.StringWriter:
		t.WriteString(now)
	}

	return fmt.Errorf(&#34;can not write to %T&#34;, i)
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/assertion/switch-bad/assert.go" target="_blank">src/assertion/switch-bad/assert.go</a>
    </p>
</figcaption></div>

<p>The <a href="https://staticcheck.io"><code>go-staticcheck</code></a> tool can be used to check <code>switch</code> statements for poor <code>case</code> clause organization.</p>

<cmd exec="staticcheck" exit="1" src="src/assertion/switch-bad"><pre class="code-block"><code class="language-text" language="text">$ staticcheck

assert.go:18:2: unreachable case clause: io.Writer will always match before *bytes.Buffer (SA4020)
--------------------------------------------------------------------------------
duration: 1.014469797s</code></pre></cmd>
</page><!--BREAK-->
<page>
<h1>Using Assertions</h1>

<p>Assertion doesn’t just work with empty interfaces. Any interface can be asserted against to see if it implements another interface. We can use this in our data store to add callback hooks; “before insert” and “after insert”.</p>

<div><p><pre><code class="language-go#insert" language="go#insert" src="src/store/validatable/store.go#insert">func (s *Store) Insert(m Validatable) error {

	// before insert

	// validate model
	err := m.Validate()
	if err != nil {
		return err
	}

	// insert
	s.data[m.ID()] = m

	// after insert

	return nil
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/validatable/store.go#insert" target="_blank">src/store/validatable/store.go</a>
    </p>
</figcaption></div>

<h2>Defining the Callback Interfaces</h2>

<p>We can define two new interface types in our system to support before and after insert callbacks.</p>

<div><p><pre><code class="language-go" language="go" snippet="callbacks" src="src/store/callbacks/callbacks.go">type BeforeInsertable interface {
	BeforeInsert() error
}

type AfterInsertable interface {
	AfterInsert() error
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/callbacks/callbacks.go" target="_blank">src/store/callbacks/callbacks.go</a>
    </p>
</figcaption></div>

<p>The <code>Insert</code> function can be updated to check for these new interfaces at the appropriate time in the workflow.</p>

<pre><code class="language-go" language="go" src="src/store/callbacks" sym="Store.Insert">func (s *Store) Insert(m Validatable) error {

	// snippet: before
	if bi, ok := m.(BeforeInsertable); ok {
		if err := bi.BeforeInsert(); err != nil {
			return err
		}
	}
	// snippet: before

	// validate model
	err := m.Validate()
	if err != nil {
		return err
	}

	// insert
	s.data[m.ID()] = m

	// after insert

	// snippet: after
	if ai, ok := m.(AfterInsertable); ok {
		if err := ai.AfterInsert(); err != nil {
			return err
		}
	}
	// snippet: after

	return nil
}</code></pre>

<p>These new interfaces allow a type that implements <code>Validatable</code> to opt-in to additional functionality.</p>

<h2>Breaking it Down</h2>

<p>Let’s look at how we are using these interfaces in the <code>Insert</code> method.</p>

<div><p><pre><code class="language-go" language="go" snippet="before" src="src/store/callbacks/store.go">if bi, ok := m.(BeforeInsertable); ok {
	if err := bi.BeforeInsert(); err != nil {
		return err
	}
}</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/callbacks/store.go" target="_blank">src/store/callbacks/store.go</a>
    </p>
</figcaption></div>

<p>If the <code>m</code> variable, of type <code>Validatable</code> (interface), can be asserted to the <code>BeforeInsertable</code> interface, then the <code>bi</code> variable will be of type <code>BeforeInsertable</code> and <code>ok</code> will be <code>true</code>. The <code>BeforeInsert</code> method will be called, the error it returns will be checked, and the application will continue or will return the error. If, however, <code>m</code> does not implement <code>BeforeInsertable</code> then <code>ok</code> will return <code>false</code> and the <code>BeforeInsert</code> method will never be called.</p>

<p>We check the <code>AfterInsertable</code> interface in the same way.</p>

<div><p><pre><code class="language-go" language="go" snippet="after" src="src/store/callbacks/store.go">if ai, ok := m.(AfterInsertable); ok {
	if err := ai.AfterInsert(); err != nil {
		return err
	}
}</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="src/store/callbacks/store.go" target="_blank">src/store/callbacks/store.go</a>
    </p>
</figcaption></div>
</page><!--BREAK-->
</include>
<include src="generics/generics.md"><page>
<h1>Generics</h1>

<p><a href="https://en.wikipedia.org/wiki/Generic_programming">Generics</a> were first introduced to Go with the release of <a href="https://go.dev/blog/intro-generics">Go 1.18</a>. Go 1.18 was release in March of 2022, during the writing of this course. We, like the Go team, have tried our best to present the current idioms and thoughts on the how, what, when, where, and why questions about generics in Go.</p>

<h2>What are Generics?</h2>

<p>Generic programming is a programming paradigm that allows us to stub out the implementation of a function with a type that will be provided later. This has benefits for both writing, and using, generic functions. With generics we can write functions that can work with multiple types directly, without having to write the same function multiple times, once for each type. When using generic functions, we can continue use our types as concrete types, instead of interface representations.</p>

<h2>The Problem with Interfaces</h2>

<p>Interfaces in Go are a powerful tool that has allowed developers to create some very powerful tools in Go. Interfaces allow us to define a set of methods that describe the behavior of a type. Any type that implements those methods, and behaviors, is considered to implement that interface.</p>

<p>We have already discussed the benefits and drawbacks of interfaces earlier in this course so we don’t have to re-iterate the benefits of interfaces, but let’s discuss some problems with interfaces. For example, let’s consider the problem of how to write a function that will return the keys for a given map.</p>

<pre><code class="language-go" language="go" src="generics/src/keys/any" sym="Keys">func Keys(m map[any]any) []any {

	// make a slice of the keys
	keys := make([]any, 0, len(m))

	// iterate over the map
	for k := range m {

		// add the key to the slice
		keys = append(keys, k)
	}

	// return the keys
	return keys
}</code></pre>

<p>Go is a statically typed language and so we have to specify the type of the map that we want to get the keys from. A map needs to have both its key and value types specified. We also need to specify the type of slice this function will be returning. In order for this function to support all map types we need to use the <code>any</code>, or empty interface, type which will match any type.</p>

<p>While this means we can write a function that we return a list of keys from a map, it also means that this function is difficult to use. Consider a test that tries use a map that isn’t of type <code>map[any]any</code>. This code fails to compile because the type of map in the test is not compatible with the type of map required by the function.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" language="go#example" src="generics/src/keys/any/keys_test.go#example">func Test_Keys(t *testing.T) {
	t.Parallel()

	// create a map with some values
	m := map[int]string{
		1: &#34;one&#34;,
		2: &#34;two&#34;,
		3: &#34;three&#34;,
	}

	// get the keys
	act := Keys(m)

	// sort the returned keys for comparison
	sort.Slice(act, func(i, j int) bool {
		return act[i] &lt; act[j]
	})

	// set the expected values
	exp := []int{1, 2, 3}

	// assert the length of the actual and expected values
	al := len(act)
	el := len(exp)
	if al != el {
		t.Fatalf(&#34;expected %d, but got %d&#34;, el, al)
	}

	// loop through the expected values and
	// assert they are in the actual values
	for i, v := range exp {
		if v != act[i] {
			t.Fatalf(&#34;expected %d, but got %d&#34;, v, act[i])
		}
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/any/keys_test.go#example" target="_blank">generics/src/keys/any/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" src="generics/src/keys/any"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys_test.go:20:14: cannot use m (variable of type map[int]string) as type map[any]any in argument to Keys
./keys_test.go:24:10: invalid operation: act[i] &lt; act[j] (operator &lt; not defined on interface)
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>To solve this problem we would need to create a new, interstitial map of the correct type, and copy all of the keys from the original map into the new map. The same is true of trying to handle the results. We need to loop through the returned slice of keys, asserts the keys are of the correct type, and then copy those values into a new slice of the correct type.</p>

<div><p><pre><code class="language-go" language="go" src="generics/src/keys/any/keys.go">package demo

func Keys(m map[any]any) []any {

	// make a slice of the keys
	keys := make([]any, 0, len(m))

	// iterate over the map
	for k := range m {

		// add the key to the slice
		keys = append(keys, k)
	}

	// return the keys
	return keys
}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/any/keys.go" target="_blank">generics/src/keys/any/keys.go</a>
    </p>
</figcaption></div>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/keys/fixed/keys_test.go#example">// create a map with some values
m := map[int]string{
	1: &#34;one&#34;,
	2: &#34;two&#34;,
	3: &#34;three&#34;,
}

// create an interstitial map to pass to the function
im := map[any]any{}

// copy the map into the interstitial map
for k, v := range m {
	im[k] = v
}

// get the keys
keys := Keys(im)

// create a slice to hold the keys as
// integers for comparison
act := make([]int, 0, len(keys))

// copy the keys into the integer slice
for _, k := range keys {
	// assert that the key is an int
	i, ok := k.(int)
	if !ok {
		t.Fatalf(&#34;expected type int, got %T&#34;, k)
	}

	act = append(act, i)
}

// sort the returned keys for comparison
sort.Slice(act, func(i, j int) bool {
	return act[i] &lt; act[j]
})</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/fixed/keys_test.go#example" target="_blank">generics/src/keys/fixed/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/keys/fixed"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>While this fixes the tests, it is a very cumbersome way to work with a function such as this. Generics, were designed to help solve exactly this sort of problem.</p>

<h2>Type Constraints</h2>

<p>Generics in Go introduced a new concept to the language, called Type Constraints. Type Constraints allow us to specify that a type fits within a certain set of constraints. This is useful when we want to write a function that can work with multiple types, but we want to be able to specify that the function can only work with a specific type.</p>

<p>For example, so far have been using an <code>int</code> for the key type in a map, and <code>string</code> for the value type. This is fine, but we can use generics to make this more flexible. We may want to use an <code>int32</code> or a <code>float64</code> for the key type, and <code>any</code> value for the value type.</p>

<p>Generics allows us to specify those types as constraints when defining a function or a type. Constraints are added with <code>[]</code> after the name of the function or type, but before any parameters.</p>

<pre class="code-block"><code class="language-go" language="go">func Name[constraints](parameters) (returns) {
	// ...
}
</code></pre>

<p>For example, we can define an <code>Slicer</code> function that defines a constraint, type <code>T</code>, which can be of <code>any</code> type. That new <code>T</code> type can then be used in the function signature. In this, the <code>Slicer</code> function will return a slice of <code>T</code> values.</p>

<pre><code class="language-go" language="go" src="generics/src/slicer" sym="Slicer">func Slicer[T any](input T) []T {
	return []T{input}
}</code></pre>

<p>When calling the <code>Slicer</code> function we can pass any type, and it returns a slice of that same type back.</p>

<div><div><p><pre><code class="language-go#example" code="slicer_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/slicer/slicer_test.go#example">func Test_Slicer(t *testing.T) {
	t.Parallel()

	// create input string
	input := &#34;Hello World&#34;

	// capture output []string
	act := Slicer(input)

	exp := []string{input}

	if len(act) != len(exp) {
		t.Fatalf(&#34;expected %v, got %v&#34;, exp, act)
	}

	for i, v := range exp {
		if act[i] != v {
			t.Fatalf(&#34;expected %v, got %v&#34;, exp, act)
		}
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/slicer/slicer_test.go#example" target="_blank">generics/src/slicer/slicer_test.go</a>
    </p>
</figcaption></div><cmd code="slicer_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/slicer"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Slicer
=== PAUSE Test_Slicer
=== CONT  Test_Slicer
--- PASS: Test_Slicer (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>In our tests we passed a <code>string</code> type to the <code>Slicer</code> function. At compile time, sees that we are calling the <code>Slicer</code> function with a <code>string</code> type and then inserts a function with the appropriate typed signature. For example, by passing a <code>string</code> type, the compiler generates a function like the following.</p>

<pre><code class="language-go" language="go" src="generics/src/slicer-static" sym="Slicer">func Slicer(input string) []string {
	return []string{input}
}</code></pre>

<h2>Multiple Generic Types</h2>

<p>With an understanding of the basics of generics, let’s go back to our <code>Keys</code> function and update it to support generics.</p>

<div><p><pre><code class="language-go#def" language="go#def" src="generics/src/keys/fixed/keys.go#def">func Keys(m map[any]any) []any {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/fixed/keys.go#def" target="_blank">generics/src/keys/fixed/keys.go</a>
    </p>
</figcaption></div>

<p>A map has both a key and a value type. We can use generics to specify which types are allowed to be used for both. For example, we can specify that the key type, <code>K</code>, must of a type <code>int</code>, but the value type, <code>V</code>, can be of any type.</p>

<div><p><pre><code class="language-go#def" language="go#def" src="generics/src/keys/generic/start/keys.go#def">func Keys[K int, V any](m map[K]V) []K {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/generic/start/keys.go#def" target="_blank">generics/src/keys/generic/start/keys.go</a>
    </p>
</figcaption></div>

<p>With this change we can pass a map of key type <code>int</code> and a value type of <code>string</code> to the <code>Keys</code> function and it will return a slice of <code>int</code> values.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/keys/generic/start/keys_test.go#example">// create a map with some values
m := map[int]string{
	1: &#34;one&#34;,
	2: &#34;two&#34;,
	3: &#34;three&#34;,
}

// get the keys
act := Keys(m)

// sort the returned keys for comparison
sort.Slice(act, func(i, j int) bool {
	return act[i] &lt; act[j]
})

// set the expected values
exp := []int{1, 2, 3}

// assert the length of the actual and expected values
if len(exp) != len(act) {
	t.Fatalf(&#34;expected len(%d), but got len(%d)&#34;, len(exp), len(act))
}

// assert the types of the actual and expected values
at := fmt.Sprintf(&#34;%T&#34;, act)
et := fmt.Sprintf(&#34;%T&#34;, exp)

if at != et {
	t.Fatalf(&#34;expected type %s, but got type %s&#34;, et, at)
}

// loop through the expected values and
// assert they are in the actual values
for i, v := range exp {
	if v != act[i] {
		t.Fatalf(&#34;expected %d, but got %d&#34;, v, act[i])
	}
}</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/keys/generic/start/keys_test.go#example" target="_blank">generics/src/keys/generic/start/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/keys/generic/start"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>This however, doesn’t work if we want to use a map key of type <code>string</code> or <code>float64</code>. To do this we will need to specify a bigger set of constraints for the key type.</p>

<h2>Instantiating Generic Functions</h2>

<p>When calling a generic function, or creating a new value of a generic type, the Go compiler needs to know which types are being provided for the generic parameters. So far, we have been letting the Go compiler infer the types of the generic parameters based on the types of the values passed in. However, if we were to, instead of call a generic function directly, create a variable pointing to the generic function, the Go compiler will not know the types of the generic parameters and the code will fail to compile.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" language="go#example" src="generics/src/instantiation/broken/keys_test.go#example">// create a function variable pointing
// to the Keys function
fn := Keys

// get the keys
act := fn(m)</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/instantiation/broken/keys_test.go#example" target="_blank">generics/src/instantiation/broken/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" src="generics/src/instantiation/broken"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys_test.go:22:8: cannot use generic function Keys without instantiation
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>In these situations we need to provide the compiler with the types of the generic parameters.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/instantiation/fixed/keys_test.go#example">// create a function variable pointing
// to the Keys function
fn := Keys[int, string]

// get the keys
act := fn(m)</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/instantiation/fixed/keys_test.go#example" target="_blank">generics/src/instantiation/fixed/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/instantiation/fixed"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<h2>Defining Constraints</h2>

<p>So far we have been using pretty simple types, such as <code>int</code> and <code>any</code> for the key and value types. But what if we wanted to use more types than just these? To specify which types can be used for a generic parameter, we can use constraints. Constraints are defined in a similar way to interfaces, but instead of specifying a set of methods, we specify a set of types.</p>

<p>As a start we can define a constraint that requires the type to be an <code>int</code>.</p>

<pre><code class="language-go" language="go" src="generics/src/constraints/defining" sym="MapKey">// MapKey is a set of a constraints
// on types that can be used as map keys.
type MapKey interface {
	int
}</code></pre>

<p>With a <code>MapKey</code> constraint defined we can update the <code>Keys</code> function to use it instead of <code>int</code>.</p>

<div><p><pre><code class="language-go#def" language="go#def" src="generics/src/constraints/defining/keys.go#def">func Keys[K MapKey, V any](m map[K]V) []K {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/constraints/defining/keys.go#def" target="_blank">generics/src/constraints/defining/keys.go</a>
    </p>
</figcaption></div>

<h2>Multiple Type Constraints</h2>

<p>Currently, the <code>MapKey</code> constraint only allows an <code>int</code> to be used for the key. If we were to try and use the <code>Keys</code> function with a map using a key type of <code>float64</code> we would get a compile error.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" language="go#example" src="generics/src/constraints/floats/keys_test.go#example">// create a map with some values
m := map[float64]string{
	1.1: &#34;one&#34;,
	2.2: &#34;two&#34;,
	3.3: &#34;three&#34;,
}

// get the keys
act := Keys(m)

// sort the returned keys for comparison
sort.Slice(act, func(i, j int) bool {
	return act[i] &lt; act[j]
})

// set the expected values
exp := []float64{1.1, 2.2, 3.3}

// assert the length of the actual and expected values
if len(exp) != len(act) {
	t.Fatalf(&#34;expected len(%d), but got len(%d)&#34;, len(exp), len(act))
}

// assert the types of the actual and expected values
at := fmt.Sprintf(&#34;%T&#34;, act)
et := fmt.Sprintf(&#34;%T&#34;, exp)

if at != et {
	t.Fatalf(&#34;expected type %s, but got type %s&#34;, et, at)
}

// loop through the expected values and
// assert they are in the actual values
for i, v := range exp {
	if v != act[i] {
		t.Fatalf(&#34;expected %d, but got %d&#34;, v, act[i])
	}
}</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/constraints/floats/keys_test.go#example" target="_blank">generics/src/constraints/floats/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" src="generics/src/constraints/floats"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys_test.go:21:13: float64 does not implement MapKey
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>When defining constraints we can use the <code>|</code> operator to create an intersection of constraints. For example, we can define a constraint that requires the key type to be either <code>int</code> or <code>float64</code>.</p>

<pre><code class="language-go" language="go" src="generics/src/constraints/or" sym="MapKey">// MapKey is a set of a constraints
// on types that can be used as map keys.
type MapKey interface {
	int | float64
}</code></pre>

<p>With this change to the <code>MapKey</code> constraint we can now use the <code>Keys</code> function with a map using a key type of <code>float64</code>.</p>

<cmd exec="go test -v" hide-duration="true" src="generics/src/constraints/or"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<h2>Underlying Type Constraints</h2>

<p>In Go, we are allowed to create new types based on other types. For example, we can create a new type, <code>MyInt</code>, that is based on the <code>int</code> type.</p>

<pre><code class="language-go" language="go" src="generics/src/constraints/underlying/broken" sym="MyInt">type MyInt int</code></pre>

<p>However, when we try to use the <code>Keys</code> function with a map using a key type of <code>MyInt</code> we will get a compile error.</p>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" language="go#example" src="generics/src/constraints/underlying/broken/keys_test.go#example">// create a map with some values
m := map[MyInt]string{
	1: &#34;one&#34;,
	2: &#34;two&#34;,
	3: &#34;three&#34;,
}

// get the keys
act := Keys(m)

// sort the returned keys for comparison
sort.Slice(act, func(i, j int) bool {
	return act[i] &lt; act[j]
})

// set the expected values
exp := []MyInt{1, 2, 3}

// assert the length of the actual and expected values
if len(exp) != len(act) {
	t.Fatalf(&#34;expected len(%d), but got len(%d)&#34;, len(exp), len(act))
}

// assert the types of the actual and expected values
at := fmt.Sprintf(&#34;%T&#34;, act)
et := fmt.Sprintf(&#34;%T&#34;, exp)

if at != et {
	t.Fatalf(&#34;expected type %s, but got type %s&#34;, et, at)
}

// loop through the expected values and
// assert they are in the actual values
for i, v := range exp {
	if v != act[i] {
		t.Fatalf(&#34;expected %d, but got %d&#34;, v, act[i])
	}
}</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/constraints/underlying/broken/keys_test.go#example" target="_blank">generics/src/constraints/underlying/broken/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" exit="2" hide-duration="true" src="generics/src/constraints/underlying/broken"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys_test.go:21:13: MyInt does not implement MapKey (possibly missing ~ for int in constraint MapKey)
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<p>The reason for this compilation is that the type <code>MyInt</code>, while based on <code>int</code>, does not satisfy the <code>MapKey</code> constraint because it is <strong>not</strong> an <code>int</code> itself. When writing constraints we, usually, are interested in the underlying type, not the type that is wrapped by the type. To express this in when defining a constraint we can use the <code>~</code> operator.</p>

<pre><code class="language-go" language="go" src="generics/src/constraints/underlying/fixed" sym="MapKey">// MapKey is a set of a constraints
// on types that can be used as map keys.
type MapKey interface {
	~int
}</code></pre>

<p>By updating the constraint to use the <code>~</code> operator we can now use the <code>Keys</code> function with a map using a key type of <code>MyInt</code>.</p>

<cmd exec="go test -v" hide-duration="true" src="generics/src/constraints/underlying/fixed"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<h2>The Constraints Package</h2>

<p>When generics were released in Go 1.18, the Go team, decided to be cautious and not update the standard library immediately to use them. They wanted to see how generics were being used before deciding to update the standard library. As a result of this, the Go team have create a series of packages in the <godoc#a for="golang.org/x/exp"><a href="https://pkg.go.dev/golang.org/x/exp" target="_blank"><code>golang.org/x/exp</code></a></godoc#a> namespace to experiment with generics. One of these packages is the <godoc#a for="golang.org/x/exp/constraints"><a href="https://pkg.go.dev/golang.org/x/exp/constraints" target="_blank"><code>golang.org/x/exp/constraints</code></a></godoc#a> package. The <godoc#a for="golang.org/x/exp/constraints"><a href="https://pkg.go.dev/golang.org/x/exp/constraints" target="_blank"><code>golang.org/x/exp/constraints</code></a></godoc#a> package defines a set of constraints for all of the numerical, and comparable types in the language.</p>

<cmd exec="go doc golang.org/x/exp/constraints" hide-duration="true" src="generics/src/constraints/pkg"><pre class="code-block"><code class="language-text" language="text">$ go doc golang.org/x/exp/constraints

package constraints // import &#34;golang.org/x/exp/constraints&#34;

Package constraints defines a set of useful constraints to be used with type
parameters.

type Complex interface{ ... }
type Float interface{ ... }
type Integer interface{ ... }
type Ordered interface{ ... }
type Signed interface{ ... }
type Unsigned interface{ ... }
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>For example, consider the <godoc#a for="golang.org/x/exp/constraints#Signed"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Signed" target="_blank"><code>constraints.Signed</code></a></godoc#a> constraint. This constraint requires that the type be any of the signed integer types defined in the Go language, and any types based on those types.</p>

<cmd exec="go doc golang.org/x/exp/constraints.Signed" hide-duration="true" src="generics/src/constraints/pkg"><pre class="code-block"><code class="language-text" language="text">$ go doc golang.org/x/exp/constraints.Signed

package constraints // import &#34;golang.org/x/exp/constraints&#34;

type Signed interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64
}
    Signed is a constraint that permits any signed integer type. If future
    releases of Go add new predeclared signed integer types, this constraint
    will be modified to include them.
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<h3>The Ordered Constraint</h3>

<p>One of the most useful constraints defined in the <godoc#a for="golang.org/x/exp/constraints"><a href="https://pkg.go.dev/golang.org/x/exp/constraints" target="_blank"><code>golang.org/x/exp/constraints</code></a></godoc#a> package is the <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> constraint. This constraint list all of the comparable types in the language, and any types based on those types. The <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> constraint covers all numerical types and strings.</p>

<cmd exec="go doc golang.org/x/exp/constraints.Ordered" hide-duration="true" src="generics/src/constraints/pkg"><pre class="code-block"><code class="language-text" language="text">$ go doc golang.org/x/exp/constraints.Ordered

package constraints // import &#34;golang.org/x/exp/constraints&#34;

type Ordered interface {
	Integer | Float | ~string
}
    Ordered is a constraint that permits any ordered type: any type that
    supports the operators &lt; &lt;= &gt;= &gt;. If future releases of Go add new ordered
    types, this constraint will be modified to include them.
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>The <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> constraint is perfect for map keys because all of the types defined in the constraint are comparable. By updating the <code>Keys</code> function to use the <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> constraint we can now use the <code>Keys</code> function with a map using a key type of <code>string</code>, or any other type that is comparable.</p>

<div><p><pre><code class="language-go#def" language="go#def" src="generics/src/constraints/pkg/keys.go#def">func Keys[K constraints.Ordered, V any](m map[K]V) []K {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/constraints/pkg/keys.go#def" target="_blank">generics/src/constraints/pkg/keys.go</a>
    </p>
</figcaption></div>

<div><div><p><pre><code class="language-go#example" code="keys_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/constraints/pkg/keys_test.go#example">// create a map with some values
m := map[string]int{
	&#34;a&#34;: 1,
	&#34;b&#34;: 2,
	&#34;c&#34;: 3,
}

// get the keys
act := Keys(m)</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/constraints/pkg/keys_test.go#example" target="_blank">generics/src/constraints/pkg/keys_test.go</a>
    </p>
</figcaption></div><cmd code="keys_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/constraints/pkg"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Keys
=== PAUSE Test_Keys
=== CONT  Test_Keys
--- PASS: Test_Keys (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<h2>Type Assertions</h2>

<p>When using constraints that are based on types, and not on methods like interfaces, type assertions are not allowed. For example, inside the <code>Keys</code> functions we might want to print the key out to the console, but only if it implements the <godoc#a for="fmt#Stringer"><a href="https://pkg.go.dev/fmt#Stringer" target="_blank"><code>fmt.Stringer</code></a></godoc#a> interface.</p>

<pre><code class="language-go" language="go" src="generics/src/assertions/broken" sym="Keys">// snippet: def
func Keys[K constraints.Ordered, V any](m map[K]V) []K {
	// snippet: def

	// make a slice of the keys
	keys := make([]K, 0, len(m))

	// iterate over the map
	for k := range m {

		// if k implements fmt.Stringer,
		// print the string representation
		if st, ok := k.(fmt.Stringer); ok {
			fmt.Println(st.String())
		}

		// add the key to the slice
		keys = append(keys, k)
	}

	// return the keys
	return keys
}</code></pre>

<p>With method based interfaces this is possible, but with constraints we can’t make this sort of assertion.</p>

<cmd exec="go test -v" exit="2" hide-duration="true" src="generics/src/assertions/broken"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys.go:21:16: invalid operation: cannot use type assertion on type parameter value k (variable of type K constrained by constraints.Ordered)
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>As mentioned earlier, at compile time, generic function calls are replaced with their concrete types instead. The result is a <code>Keys</code> function that takes a map of <code>string</code> to <code>int</code> and returns a <code>[]string</code>.</p>

<pre><code class="language-go" language="go" src="generics/src/assertions/static" sym="Keys">// snippet: def
func Keys(m map[string]int) []string {
	// snippet: def

	// make a slice of the keys
	keys := make([]string, 0, len(m))

	// iterate over the map
	for k := range m {

		// if k implements fmt.Stringer,
		// print the string representation
		if st, ok := k.(fmt.Stringer); ok {
			fmt.Println(st.String())
		}

		// add the key to the slice
		keys = append(keys, k)
	}

	// return the keys
	return keys
}</code></pre>

<p>When looking at the compilation error for “concrete” representation of the <code>Keys</code> function the error is a little more clear.</p>

<cmd exec="go test -v" exit="2" hide-duration="true" src="generics/src/assertions/static"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys.go:19:16: invalid operation: k (variable of type string) is not an interface
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd>

<p>In Go type assertions, such as this, against concrete types is not allowed. This is no reason to assert if <code>string</code> or <code>User</code> or another types implements the interface, because the compiler already if it can be done.</p>

<h2>Mixing Method and Type Constraints</h2>

<p>When defining constraints we have to choose between type based constraints and method based constraints. For example, can can’t define a constraint that is either <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> or <godoc#a for="fmt#Stringer"><a href="https://pkg.go.dev/fmt#Stringer" target="_blank"><code>fmt.Stringer</code></a></godoc#a>.</p>

<pre><code class="language-go" language="go" src="generics/src/assertions/mixed" sym="MapKey">type MapKey interface {
	constraints.Ordered | fmt.Stringer
}</code></pre>

<div><div><p><pre><code class="language-go#def" code="keys.go#def" exec="go test -v" exit="2" hide-duration="true" language="go#def" src="generics/src/assertions/mixed/keys.go#def">func Keys[K MapKey, V any](m map[K]V) []K {</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/assertions/mixed/keys.go#def" target="_blank">generics/src/assertions/mixed/keys.go</a>
    </p>
</figcaption></div><cmd code="keys.go#def" exec="go test -v" exit="2" hide-duration="true" src="generics/src/assertions/mixed"><pre class="code-block"><code class="language-text" language="text">$ go test -v

FAIL	demo [build failed]
--------------------------------------------------------------------------------
STDERR:

# demo [demo.test]
./keys.go:10:24: cannot use fmt.Stringer in union (fmt.Stringer contains methods)
./keys.go:14:34: invalid map key type K (missing comparable constraint)
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>

<h2>Generic Types</h2>

<p>In addition to functions, types can also be generic. If we return to the earlier store example, we could update the <code>Model</code> interface to use generics allowing us to use a generic type for the <code>ID()</code> method to return.</p>

<pre><code class="language-go" language="go" src="generics/src/store" sym="Model">type Model[T constraints.Ordered] interface {
	ID() T
}</code></pre>

<p>Now, in order to implement the <code>Model</code> interface a type needs a <code>ID()</code> method that returns a type listed in the <godoc#a for="golang.org/x/exp/constraints#Ordered"><a href="https://pkg.go.dev/golang.org/x/exp/constraints#Ordered" target="_blank"><code>constraints.Ordered</code></a></godoc#a> constraint.</p>

<pre><code class="language-go" language="go" src="generics/src/store" sym="User">type User struct {
	Email string
}

func (u User) ID() string</code></pre>

<p>We can update the <code>Store</code> type as well to use two constraints, one for the type of map key to be used and the other the <code>Model</code> constraint.</p>

<pre><code class="language-go" language="go" src="generics/src/store" sym="Store">// Store is a map of models where the map key is any
// comparable type and the map value is any type that
// implements the Model constraint.
type Store[K constraints.Ordered, M Model[K]] struct {
	data map[K]M
}

func (s Store[K, M]) Find(id K) (M, error)
func (s *Store[K, M]) Insert(m M) error</code></pre>

<p>When defining methods on types that use generics, the receiver of the method needs to be instantiated with the appropriate concrete type or types. Consider the <code>Find</code> method on the <code>Store</code> type.</p>

<pre><code class="language-go" language="go" src="generics/src/store" sym="Store.Find">func (s Store[K, M]) Find(id K) (M, error) {
	m, ok := s.data[id]
	if !ok {
		return m, fmt.Errorf(&#34;key not found %v&#34;, id)
	}

	return m, nil
}</code></pre>

<p>The receiver, <code>(s Store[K, M])</code>, is instantiated with the concrete types that the <code>Store</code> type was instantiated with. Those types can also be used to define arguments and return values for these methods.</p>

<div><div><p><pre><code class="language-go#example" code="store_test.go#example" exec="go test -v" hide-duration="true" language="go#example" src="generics/src/store/store_test.go#example">func Test_Store_Insert(t *testing.T) {
	t.Parallel()

	// create a store
	s := &amp;Store[string, User]{
		data: map[string]User{},
	}

	// create a user
	exp := User{Email: &#34;kurt@exampl.com&#34;}

	// insert the user
	err := s.Insert(exp)
	if err != nil {
		t.Fatal(err)
	}

	// retreive the user
	act, err := s.Find(exp.Email)
	if err != nil {
		t.Fatal(err)
	}

	// assert the returned user is the same as the inserted user
	if exp.Email != act.Email {
		t.Fatalf(&#34;expected %v, got %v&#34;, exp, act)
	}

}
</code></pre></p><figcaption>
    <p style="text-align: center;">
        Source file: <a href="generics/src/store/store_test.go#example" target="_blank">generics/src/store/store_test.go</a>
    </p>
</figcaption></div><cmd code="store_test.go#example" exec="go test -v" hide-duration="true" src="generics/src/store"><pre class="code-block"><code class="language-text" language="text">$ go test -v

=== RUN   Test_Store_Insert
=== PAUSE Test_Store_Insert
=== CONT  Test_Store_Insert
--- PASS: Test_Store_Insert (0.00s)
PASS
ok  	demo	0.005s
--------------------------------------------------------------------------------
go: go1.18</code></pre></cmd></div>
</page><!--BREAK-->
</include>
</body></html>
